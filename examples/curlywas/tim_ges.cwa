fn melody(ch: i32, t: i32, T: i32) {
    let lazy riff_pos = abs(((T&31) - 16) as f32) as i32;
    let lazy shift = ((1-((T>>5)&3))%2-1) * 2;

    let inline note_count = 5 - (T >= 512);
    let inline octave = (riff_pos/5) * 12;
    let inline riff_note = 5514 >> (riff_pos % note_count * 4) & 15;
    let inline melody_note = shift + octave - riff_note;

    ch?1 = riff_pos * 10 + 4;
    ch?3 = melody_note + 64;

    let inline arp_note = shift + ((0x85>>((t/2)%3*4)) & 15) - 1;
    80?3 = arp_note + 64;
}

export fn upd() {
    let lazy t = 32!32 / (1000/60);
    let lazy T = t / 7;
    melody(98, t, T - 3);
    melody(92, t, T);

    80?0 = ((T >= 256) & (T/12+(T-3)/12)) * 2 | 0x4; // arp trigger

    if T >= 128 {
        let inline bass_step = T % 8;
        86?3 = if bass_step / 2 == 2 {
            86?0 = 0xc2;
            90
        } else {
            86?0 = ((197 >> bass_step) & 1) | 0x48;
            ((T & 4) * ((T & 7) - 1)) / 2 + 28
        };
    }
}

data 80 {
    i8(
        0, 64, 0, 128, 0, 0xe,
        0, 128, 0, 128, 0, 0xc8,
        5, 128, 0, 128, 0, 0xc8,
        5, 128, 0, 128, 0, 0xc8,
        0xf8, 0x85,
        0xc1, 0xf1, 0, 110, 0, 80
    )
}

/*

include "../../platform/src/ges.cwa"

import "env.pow" fn pow(f32, f32) -> f32;
import "env.sin" fn sin(f32) -> f32;

export fn snd(t: i32) -> f32 {
    gesSnd(t)
}

*/